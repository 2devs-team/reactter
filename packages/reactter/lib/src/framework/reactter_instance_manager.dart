part of '../framework.dart';

/// A mixin-class that adds instances management features
/// to classes that use it.
///
/// It allows registering, unregistering, getting, creating,
/// and deleting instances of a certain type.
///
/// It also provides methods to check if an instance exists
/// and to get the instance of a certain type with a given ID.
///
/// It stores instances and their builders, and
/// emits lifecycle events when instances are registered, unregistered,
/// initialized, and destroyed.
abstract class ReactterInstanceManager {
  /// It's used to store instances of a certain
  /// type with a unique key generated by `ReactterInstance.generateKey<T?>(id)`.
  final _instancesByKey = HashMap<String, _ReactterInstanceBuilder>();

  /// It's used to keep track of the instances that have been created,
  /// so they can be accessed and managed later.
  final _instancesCreated = HashMap<Object, _ReactterInstanceBuilder>();

  /// {@template register}
  /// Register a [builder] function
  /// for creating a new instance of [T] with an [id] optional.
  /// {@endtemplate}
  ///
  /// Use [type] parameter for defining how to manage the instance.
  ///
  /// Returns `true` when instance has been registered.
  bool register<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
    InstanceType type = InstanceType.builder,
  }) {
    final instanceKey = ReactterInstance.generateKey<T?>(id);
    var reactterInstance = _instancesByKey[instanceKey];

    if (reactterInstance?.builder != null) {
      Reactter.log(
        'The "$reactterInstance" builder already registered as `$type`.',
      );
      return false;
    }

    reactterInstance =
        _instancesByKey[instanceKey] = _ReactterInstanceBuilder<T>(
      builder,
      id: id,
      type: type,
    );

    Reactter.emit(reactterInstance, Lifecycle.registered);
    Reactter.log(
      'The "$reactterInstance" builder has been registered as `$type`.',
    );
    return true;
  }

  /// {@template lazy_builder}
  /// Register a [builder] function for creating a new instance
  /// of [T] with an [id] optional as [InstanceType.builder].
  /// {@endtemplate}
  ///
  /// Returns `true` when instance has been registered.
  ///
  /// {@macro builder}
  ///
  /// This method is equivalent to calling:
  ///
  /// ```dart
  /// Reactter.register<T>(
  ///   builder,
  ///   id: id,
  ///   type: InstanceType.builder,
  /// );
  bool lazyBuilder<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
  }) {
    return register<T>(
      builder,
      id: id,
      type: InstanceType.builder,
    );
  }

  /// {@template lazy_factory}
  /// Register a [builder] function for creating a new instance
  /// of [T] with an [id] optional as [InstanceType.factory].
  /// {@endtemplate}
  ///
  /// Returns `true` when instance has been registered.
  ///
  /// {@macro factory}
  ///
  /// This method is equivalent to calling:
  ///
  /// ```dart
  /// Reactter.register<T>(
  ///   builder,
  ///   id: id,
  ///   type: InstanceType.factory,
  /// );
  bool lazyFactory<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
  }) {
    return register<T>(
      builder,
      id: id,
      type: InstanceType.factory,
    );
  }

  /// {@template lazy_singleton}
  /// Register a [builder] function for creating a new instance
  /// of [T] with an [id] optional as [InstanceType.singleton].
  /// {@endtemplate}
  ///
  /// Returns `true` when instance has been registered.
  ///
  /// {@macro singleton}
  ///
  /// This method is equivalent to calling:
  ///
  /// ```dart
  /// Reactter.register<T>(
  ///   builder,
  ///   id: id,
  ///   type: InstanceType.singleton,
  /// );
  bool lazySingleton<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
  }) {
    return register<T>(
      builder,
      id: id,
      type: InstanceType.singleton,
    );
  }

  /// {@template create}
  /// Registers, creates and/or gets the instance of [T] with an [id] optional.
  /// {@endtemplate}
  ///
  /// Use [type] parameter for defining how to manage the instance.
  ///
  /// {@template create_conditions}
  /// Under the following conditions:
  ///
  /// - if not found and hasn't registered it, registers, creates and returns it.
  /// - if not found and has registered it, creates and returns it.
  /// - if found it, returns it.
  /// - else return `null`.
  /// {@endtemplate}
  T? create<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
    Object? ref,
    InstanceType type = InstanceType.builder,
  }) {
    register<T>(builder, id: id, type: type);

    return _getOrCreateIfNotExtist<T>(id, ref)?.instance;
  }

  /// {@template builder}
  /// Registers, creates and/or gets the instance of [T] type with an [id] optional
  /// as [InstanceType.builder].
  /// {@endtemplate}
  ///
  /// {@macro create_conditions}
  ///
  /// {@macro builder}
  ///
  /// This method is equivalent to calling:
  ///
  /// ```dart
  /// Reactter.create<T>(
  ///   builder,
  ///   id: id,
  ///   ref: ref,
  ///   type: InstanceType.builder,
  /// );
  /// ```
  T? builder<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
    Object? ref,
  }) {
    return create<T>(
      builder,
      id: id,
      ref: ref,
      type: InstanceType.builder,
    );
  }

  /// {@template factory}
  /// Registers, creates and/or gets the instance of [T] type with an [id] optional
  /// as [InstanceType.factory].
  /// {@endtemplate}
  ///
  /// {@macro create_conditions}
  ///
  /// {@macro factory}
  ///
  /// This method is equivalent to calling:
  ///
  /// ```dart
  /// Reactter.create<T>(
  ///   builder,
  ///   id: id,
  ///   ref: ref,
  ///   type: InstanceType.factory,
  /// );
  /// ```
  T? factory<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
    Object? ref,
  }) {
    return create<T>(
      builder,
      id: id,
      ref: ref,
      type: InstanceType.factory,
    );
  }

  /// {@template singleton}
  /// Registers, creates and/or gets the instance of [T] type with an [id] optional
  /// as [InstanceType.singleton].
  /// {@endtemplate}
  ///
  /// {@macro create_conditions}
  ///
  /// {@macro singleton}
  ///
  /// This method is equivalent to calling:
  ///
  /// ```dart
  /// Reactter.create<T>(
  ///   builder,
  ///   id: id,
  ///   ref: ref,
  ///   type: InstanceType.singleton,
  /// );
  /// ```
  T? singleton<T extends Object?>(
    InstanceBuilder<T> builder, {
    String? id,
    Object? ref,
  }) {
    return create<T>(
      builder,
      id: id,
      ref: ref,
      type: InstanceType.singleton,
    );
  }

  /// {@template get}
  /// Creates and/or gets the instance of [T] with an [id] optional.
  /// {@endtemplate}
  ///
  /// {@template get_conditions}
  /// Under the following conditions:
  ///
  /// - if found it, returns it.
  /// - if not found and has registered it, creates and returns it.
  /// - else returns `null`.
  /// {@endtemplate}
  T? get<T extends Object?>([String? id, Object? ref]) {
    return _getOrCreateIfNotExtist<T>(id, ref)?.instance;
  }

  /// Deletes the instance from the store
  /// if it has been removed from all references
  /// and meets the conditions of instance type.
  ///
  /// Returns `true` when the instance has been deleted.
  bool delete<T extends Object?>([String? id, Object? ref]) {
    final reactterInstance = _getReactterInstance<T>(id);

    if (reactterInstance?.instance == null) {
      final reactterInstance = ReactterInstance<T>(id);

      Reactter.log('The "$reactterInstance" instance already deleted.');

      return false;
    }

    if (ref != null) {
      reactterInstance!.refs.remove(ref.hashCode);
    }

    if (reactterInstance!.refs.isNotEmpty) {
      return false;
    }

    switch (reactterInstance.type) {
      case InstanceType.builder:
        destroy<T>(id: id);
        return true;
      case InstanceType.factory:
        _removeInstance<T>(reactterInstance);
        Reactter.log(
          'The "$reactterInstance" builder has been retained '
          'because it\'s `${InstanceType.factory}`.',
        );
        return true;
      case InstanceType.singleton:
        Reactter.log(
          'The "$reactterInstance" instance has been retained '
          'because it\'s `${InstanceType.singleton}`.',
        );
    }

    return false;
  }

  /// Removes a builder function registed of [T] type with an [id] optional.
  ///
  /// Returns `true` when instance has been unregistered.
  bool unregister<T extends Object?>([String? id]) {
    final instanceKey = ReactterInstance.generateKey<T?>(id);
    final reactterInstance =
        _instancesByKey[instanceKey] as _ReactterInstanceBuilder<T?>?;
    final typeLabel =
        reactterInstance?._stored?.type.label ?? InstanceType.builder.label;

    if (reactterInstance == null) {
      final reactterInstance = ReactterInstance<T>(id);

      Reactter.log('The "$reactterInstance" $typeLabel already deregistered.');

      return false;
    }

    if (reactterInstance._instance != null) {
      final idParam = id != null ? "id: '$id, '" : '';

      Reactter.log(
        'The "$T" builder couldn\'t deregister '
        'because the "$reactterInstance" instance is active.\n'
        'You should delete the instance before with:\n'
        '`Reactter.delete<$T>(${id ?? ''});` or \n'
        '`Reactter.destroy<$T>(${idParam}onlyInstance: true);`\n',
        isError: true,
      );

      return false;
    }

    _instancesByKey.remove(instanceKey);

    Reactter.emit(reactterInstance, Lifecycle.unregistered);
    Reactter.offAll(reactterInstance);
    Reactter.log('The "$reactterInstance" $typeLabel has been deregistered.');

    return true;
  }

  /// Destroys the instance and builder of [T] type with an [id] optional.
  ///
  /// If [onlyInstance] is `true`, ignores to deresgisters the builder.
  ///
  /// Returns `true` if it was successfully.
  bool destroy<T extends Object?>({
    String? id,
    bool onlyInstance = false,
  }) {
    final reactterInstance = _getReactterInstance<T>(id);

    if (reactterInstance?.instance == null && onlyInstance) {
      final reactterInstance = ReactterInstance<T>(id);

      Reactter.log('The "$reactterInstance" instance already deleted.');

      return false;
    }

    if (reactterInstance != null) {
      reactterInstance.refs.clear();
      _removeInstance<T>(reactterInstance);
    }

    if (onlyInstance) return true;

    return unregister<T>(id);
  }

  /// {@template find}
  /// Gets the instance of [T] type with an [id] optional.
  /// {@endtemplate}
  ///
  /// If found it, returns it, else returns `null`.
  T? find<T extends Object?>([String? id]) {
    return _getReactterInstance<T>(id)?.instance;
  }

  /// Valids if the instance of [T] type with [id] optional exists.
  bool exists<T extends Object?>([String? id]) {
    return _getReactterInstance<T>(id)?.instance != null;
  }

  /// Checks if an instance is registered in Reactter.
  bool isRegistered(Object? instance) {
    return _instancesCreated[instance] != null;
  }

  /// Returns [InstanceType] of instance parameter.
  InstanceType? getInstanceType(Object? instance) {
    return _instancesCreated[instance]?.type;
  }

  /// Returns an instance of [ReactterInstance] of [T] type with an [id] optional.
  _ReactterInstanceBuilder<T?>? _getReactterInstance<T>([String? id]) {
    final instanceKey = ReactterInstance.generateKey<T?>(id);

    return _instancesByKey[instanceKey] as _ReactterInstanceBuilder<T?>?;
  }

  /// Returns or creates a [_ReactterInstanceBuilder] and logs messages related
  /// to its creation or registration.
  _ReactterInstanceBuilder<T?>? _getOrCreateIfNotExtist<T>([
    String? id,
    Object? ref,
  ]) {
    final reactterInstance = _getReactterInstance<T>(id);

    if (reactterInstance == null) {
      final reactterInstance = ReactterInstance<T>(id);
      final idParam = id != null ? ", id: '$id'" : '';

      Reactter.log(
        'The "$reactterInstance" builder is not registered.\n'
        'You should register the instance build with: \n'
        '`Reactter.register<$T>(() => $T()$idParam);` or \n'
        '`Reactter.create<$T>(() => $T()$idParam);`.',
        isError: true,
      );

      return reactterInstance._stored;
    }

    if (reactterInstance.instance != null) {
      Reactter.log('The "$reactterInstance" instance already created.');

      return reactterInstance;
    }

    ReactterZone.autoAttachInstance(
      () => _createInstance<T>(reactterInstance),
    );

    if (ref != null) {
      reactterInstance.refs.add(ref.hashCode);
    }

    Reactter.emit(reactterInstance, Lifecycle.initialized);
    Reactter.log('The "$reactterInstance" instance has been created.');

    return reactterInstance;
  }

  /// Creates an instance of a given type using a [_ReactterInstanceBuilder].
  T? _createInstance<T>(_ReactterInstanceBuilder<T?> reactterInstance) {
    reactterInstance._instance = reactterInstance.builder();

    if (reactterInstance._instance != null) {
      _instancesCreated[reactterInstance._instance!] = reactterInstance;
    }

    return reactterInstance._instance;
  }

  /// Removes an instance of a generic type from a [_ReactterInstanceBuilder].
  void _removeInstance<T>(_ReactterInstanceBuilder<T?> reactterInstance) {
    final log = 'The "$reactterInstance" instance has been deleted.';

    _instancesCreated.remove(reactterInstance.instance);

    if (reactterInstance.instance is ReactterState) {
      (reactterInstance.instance as ReactterState).dispose();
    }

    reactterInstance._instance = null;

    Reactter.emit(reactterInstance, Lifecycle.destroyed);
    Reactter.log(log);
  }
}
