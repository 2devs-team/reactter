---
title: Signal
description: The base class for all signals in Reactter.
sidebar:
  order: 0.1
---
import StateMethodsShort from '@/content/docs/shareds/state_methods_short.mdx';

<a href="https://pub.dev/documentation/reactter/latest/reactter/Signal-class.html" target="_blank">`Signal`</a> is reactive state that encapsulate a `value` changing over time. When the `value` of a signal changes, it automatically notifies its observers.

## Syntax

```dart showLineNumbers=false
  Signal<T>(T initialValue);
```

`Signal` accepts this property:

- `initialValue`: Initial value of `T` type that the signal will hold.

## Properties & Methods

`Signal` provides the following properties and methods:

- `value`: A property that allows to read and write its state.
- `ReactterState` methods(Learn more [here](/reactter/core_concepts/state_management/#state-methods)):
  <StateMethodsShort/>

## Declaration

`Signal` can be initialized using the constructor class:

```dart showLineNumbers=false
final intSignal = Signal<int>(0);
final strSignal = Signal("initial value");
final userSignal = Signal(User());
```

## Reading and writing the value

`Signal` has a `value` property that allows to read and write its state:

```dart showLineNumbers=false
intSignal.value = 10;
print("Current state: ${intSignal.value}");
```

or also can use the callable function:

```dart showLineNumbers=false
intSignal(10);
print("Current state: ${intSignal()}");
```

or simply use `.toString()` implicit to get its `value` as String:

```dart showLineNumbers=false
print("Current state: $intSignal");
```

:::note
`Signal` notifies that its `value` has changed when the previous `value` is different from the current `value`.
If its `value` is an `Object`, it does not detect internal changes, only when `value` is setted to another `Object`.
:::

:::note
When you do any arithmetic operation between two `Signal`s, it returns an `Obj`, for example: `signal(1) + Signal(2)` returns `Obj(3)`.
An [`Obj`](/reactter/classes/obj) is like a `Signal` without reactive functionality, but you can convert it to `Signal` using `.toSignal`.
:::

## Updating the value

Use `update` method to notify changes after run a set of instructions:

```dart showLineNumbers=false
userSignal.update((user) {
  user.firstname = "Firstname";
  user.lastname = "Lastname";
});
```

Use `refresh` method to force to notify changes.

```dart showLineNumbers=false
userSignal.refresh();
```

## Listening to changes

When `value` has changed, the `Signal` will emit the following events(learn about it [here](/reactter/core_concepts/lifecycle/)):

- `Lifecycle.willUpdate` event is triggered before the `value` change or `update`, `refresh` methods have been invoked.
- `Lifecycle.didUpdate` event is triggered after the `value` change or `update`, `refresh` methods have been invoked.

Example of listening to changes:

```dart showLineNumbers=false
Reactter.on(
  userSignal,
  Lifecycle.didUpdate,
  (user, _) => print("User: ${user.firstname} ${user.lastname}"),
);
```

:::note[With Flutter]
[`ReactterWatcher`](/reactter/widgets/reactter_watcher) is a way to keep the widgets automatically updates, accessing the `value` of signal reactively.
:::