---
title: Rendering Control
description: Learn how to control the rendering of components in Reactter.
sidebar:
  order: 4
  badge:
    text: flutter
---


In Flutter, efficient rendering control is essential for crafting high-performance, responsive, and scalable applications.
Reactter provides a way to easily control the rendering of components in the widget tree behavior effortlessly, using the `flutter_reactter` package.
This package provides a collection of `Widgets` and some `BuildContext` methods:

- Widgets
  - [`ReactterScope`](/reactter/widgets/reactter_scope)
  - [`ReactterWatcher`](/reactter/widgets/reactter_watcher)
  - [`ReactterProvider`](/reactter/widgets/reactter_provider)
  - [`ReactterProviders`](/reactter/widgets/reactter_providers)
  - [`ReactterConsumer`](/reactter/widgets/reactter_consumer)
  - [`ReactterSelector`](/reactter/widgets/reactter_selector)
  - [`ReactterComponent`](/reactter/widgets/reactter_component)
- Extensions
  - [`BuilderContext.use`](/reactter/extensions/builder_context_use)
  - [`BuilderContext.watch`](/reactter/extensions/builder_context_watch)
  - [`BuilderContext.watchId`](/reactter/extensions/builder_context_watch_id)
  - [`BuilderContext.select`](/reactter/extensions/builder_context_select)

## How it works

The rendering control in Reactter is based on two core concepts of Flutter:

- **InheritedWidget**: This powerful mechanism efficiently shares data across the widget tree.
Reactter extends this capability with the `ReactterProvider` widget, which stores dependencies using the dependency injection system.
This allows descendant widgets to access these dependencies as needed.
- **BuildContext Methods**: These methods facilitate dependency access and rendering control within the widget tree.
Reactter widgets like `ReactterConsumer`, `ReactterSelector`, and `ReactterComponent` use these methods to observe dependencies or states.
Whenever the dependency or any observed state undergoes a change, these widgets promptly trigger the rebuilding of the widget tree to reflect the updated state.

### Example

Let's create a simple counter app using Reactter to demonstrate how to control the rendering of the widget tree in Flutter.

```dart title="counter.dart" "count"
import 'package:reactter/reactter.dart';

class Counter {
  // Create a reactive state using the `Signal` class
  final count = Signal(0);

  void increment() {
    count.value++;
  }

  void decrement() {
    count.value--;
  }
}
```

```dart title="counter_app.dart" /Counter(?!\u0060)(?!Page)/ "Counter()" "counter" "counter.increment" "counter.decrement" "counter.count" "ReactterProvider" "ReactterConsumer"
import 'package:flutter/material.dart';
import 'package:flutter_reactter/flutter_reactter.dart';

class CounterPage extends StatelessWidget {
  const CounterPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Provide the `Counter` dependency to the widget tree
    return ReactterProvider<Counter>(
      () => Counter(), // Create an instance of the `Counter` class
      builder: (context, counter, child) {
        return Scaffold(
          appBar: AppBar(
            title: const Text("Counter"),
          ),
          body: Row(
            children: [
              ElevatedButton(
                onPressed: counter.decrement,
                child: Icon(Icons.remove),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: ReactterConsumer<Counter>(
                  // Observe the `count` property of the `Counter` object
                  listenStates: (counter) => [counter.count],
                  builder: (context, counter, child) {
                    // Rebuild the widget tree when the `count` value changes
                    return Text("${counter.count}");
                  },
                ),
              ),
              ElevatedButton(
                onPressed: counter.increment,
                child: Icon(Icons.add),
              ),
            ],
          ),
        );
      },
    );
  }
}
```

```dart title="main.dart" collapse={1-100}
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: CounterApp(),
    );
  }
}
```

Now, when you run the app, you will see a counter app with two buttons to increment and decrement the counter value.

In this scenario, only the `text` widget will be rebuilt when the `count` value changes, not the entire widget tree.
This is because the `ReactterConsumer` widget observes the `count` property and triggers the rebuilding of the widget tree when the `count` value changes.

In example, we used the `ReactterConsumer` widget to observe the `count` property of the `Counter` object,
but we can do the same functionality by using the `watch` method of the `BuildContext` class.

Here's how we can refactor the code to use the `watch` method along with a `Builder` widget to achieve the same outcome:

```dart title="counter_app.dart" collapse={1-22, 40-50} del={25-28} ins={29-34} /Counter(?!\u0060)(?!Page)/ "counter" "counter.increment" "counter.decrement" "counter.count" "ReactterProvider" "ReactterConsumer" "context.watch"
import 'package:flutter/material.dart';
import 'package:flutter_reactter/flutter_reactter.dart';

class CounterPage extends StatelessWidget {
  const CounterPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Provide the `Counter` dependency to the widget tree
    return ReactterProvider<Counter>(
      () => Counter(), // Create an instance of the `Counter` class
      builder: (context, counter, child) {
        return Scaffold(
          appBar: AppBar(
            title: const Text("Counter"),
          ),
          body: Row(
            children: [
              ElevatedButton(
                onPressed: counter.decrement,
                child: Icon(Icons.remove),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: ReactterConsumer<Counter>(
                  // Observe the `count` property of the `Counter` object
                  listenStates: (counter) => [counter.count],
                  builder: (context, counter, child) {
                child: Builder(
                  builder: (context) {
                    final counter = context.watch<Counter>(
                      // Observe the `count` property of the `Counter` object
                      (counter) => [counter.count],
                    );
                    // Rebuild the widget tree when the `count` value changes
                    return Text("${counter.count}");
                  },
                ),
              ),
              ElevatedButton(
                onPressed: counter.increment,
                child: Icon(Icons.add),
              ),
            ],
          ),
        );
      },
    );
  }
}
```

Although the `watch` method can be directly employed within the builder method of the `ReactterProvider` widget,
it's advisable to utilize it alongside a `Builder` widget to prevent unnecessary rebuilds of the widget tree.
This practice leverages the `BuildContext` scope, offering a more granular approach to rendering control within the widget tree.

For more advanced use cases, you can employ other Reactter widgets and `BuildContext` methods to further refine the rendering control of the widget tree.
By embracing these strategies, you can optimize the performance and efficiency of your Flutter applications while ensuring a seamless user experience.
