---
title: Rendering Control
description: Learn how to control the rendering of components in Reactter.
sidebar:
  order: 4
  badge:
    text: flutter
---
import { HE, HM, HT } from '@/components/Highlight/index.ts';
import { Code } from "@astrojs/starlight/components";
import counterControllerCode from '@/examples/counter/counter_controller.dart.code?raw';
import counterViewCode from '@/examples/counter/counter_view.dart.code?raw';
import counterMainCode from '@/examples/counter/main.dart.code?raw';
import { counterViewMark } from '@/examples/counter/marks.ts';

In Flutter, efficient rendering control is essential for crafting high-performance, responsive, and scalable applications.
Reactter provides a way to easily control the rendering of components in the widget tree behavior effortlessly, using the _**flutter_reactter**_ package.
This package provides a collection of <HT>`Widgets`</HT> and some <HT>`BuildContext`</HT> methods:

- Widgets
  - <HT>[`ReactterScope`](/reactter/widgets/reactter_scope)</HT>
  - <HT>[`ReactterWatcher`](/reactter/widgets/reactter_watcher)</HT>
  - <HT>[`ReactterProvider`](/reactter/widgets/reactter_provider)</HT>
  - <HT>[`ReactterProviders`](/reactter/widgets/reactter_providers)</HT>
  - <HT>[`ReactterConsumer`](/reactter/widgets/reactter_consumer)</HT>
  - <HT>[`ReactterSelector`](/reactter/widgets/reactter_selector)</HT>
  - <HT>[`ReactterComponent`](/reactter/widgets/reactter_component)</HT>
- Extensions
  - <HM>[`BuilderContext.use`](/reactter/extensions/builder_context_use)</HM>
  - <HM>[`BuilderContext.watch`](/reactter/extensions/builder_context_watch)</HM>
  - <HM>[`BuilderContext.watchId`](/reactter/extensions/builder_context_watch_id)</HM>
  - <HM>[`BuilderContext.select`](/reactter/extensions/builder_context_select)</HM>

## How it works

The rendering control in Reactter is based on two core concepts of Flutter:

- **InheritedWidget**: This powerful mechanism efficiently shares data across the widget tree.
Reactter extends this capability with the <HT>`ReactterProvider`</HT> widget, which stores dependencies using the dependency injection system.
This allows descendant widgets to access these dependencies as needed.
- **BuildContext Methods**: These methods facilitate dependency access and rendering control within the widget tree.
Reactter widgets like <HT>`ReactterConsumer`</HT>, <HT>`ReactterSelector`</HT>, and <HT>`ReactterComponent`</HT> use these methods to observe dependencies or states.
Whenever the dependency or any observed state undergoes a change, these widgets promptly trigger the rebuilding of the widget tree to reflect the updated state.

### Example

Let's create a simple counter app using Reactter to demonstrate how to control the rendering of the widget tree in Flutter.

<Code title="counter_controller.dart" code={counterControllerCode} lang="dart" mark={["count", "Signal"]} />

<Code title="counter_view.dart" code={counterViewCode} lang="dart" mark={counterViewMark} />

<Code title="main.dart" code={counterMainCode} lang="dart" />

Now, when you run the app, you will see a counter app with two buttons to increment and decrement the `count` value.

In this scenario, only the <HT>`Text`</HT> widget will be rebuilt when the `count` value changes, not the entire <HT>`CounterView`</HT> widget.
This is because the <HT>`ReactterConsumer`</HT> widget observes the `count` property and triggers the rebuilding of the widget tree when the `count` value changes.

In example, we used the <HT>`ReactterConsumer`</HT> widget to observe the `count` property of the `counterController` instance,
but we can do the same functionality by using the <HM>`watch`</HM> method of the <HT>`BuildContext`</HT> class.

Here's how we can refactor the code to use the <HM>`watch`</HM> method along with a <HT>`Builder`</HT> widget to achieve the same outcome:

```dart title="counter_view.dart" collapse={1-25, 40-51} del={26-29} ins={30-35} "ReactterProvider" "ReactterConsumer" "context.watch" "CounterController" "counterController" "counterController.increment" "counterController.decrement" "counterController.count"
import 'package:flutter/material.dart';
import 'package:flutter_reactter/flutter_reactter.dart';
import 'counter_controller.dart';

class CounterView extends StatelessWidget {
  const CounterView({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Counter"),
      ),
      // Provides the `Counter` dependency to the widget tree
      body: ReactterProvider<CounterController>(
        () => CounterController(), // Registers the `CounterController` dependency
        builder: (context, counter, child) {
          return Row(
            children: [
              ElevatedButton(
                onPressed: counter.decrement,
                child: Icon(Icons.remove),
              ),
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: ReactterConsumer<CounterController>(
                  // Observes the `count` property of the `counterController` instance
                  listenStates: (counterController) => [counterController.count],
                  builder: (context, counterController, child) {
                child: Builder(
                  builder: (context) {
                    final counterController = context.watch<CounterController>(
                      // Observes the `count` property of the `counterController` instance
                      (counterController) => [counterController.count],
                    );
                    // Rebuilds the widget tree when the `count` value changes
                    return Text("${counterController.count}");
                  },
                ),
              ),
              ElevatedButton(
                onPressed: counterController.increment,
                child: Icon(Icons.add),
              ),
            ],
          ),
        },
      );
    );
  }
}
```

Although the <HM>`watch`</HM> method can be directly employed within the builder method of the <HT>`ReactterProvider`</HT> widget,
it's advisable to utilize it alongside a <HT>`Builder`</HT> widget to prevent unnecessary rebuilds of the widget tree.
This practice leverages the <HT>`BuildContext`</HT> scope, offering a more granular approach to rendering control within the widget tree.

For more advanced use cases, you can employ other Reactter's widgets and <HT>`BuildContext`</HT> methods to further refine the rendering control of the widget tree.
By embracing these strategies, you can optimize the performance and efficiency of your Flutter applications while ensuring a seamless user experience.
