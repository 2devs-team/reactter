---
title: Reactter's Three Pillars
description: Learn about the three pillars of Reactter.
sidebar:
  order: 1
---

import { Aside } from '@astrojs/starlight/components';

Reactter is built on three pillars: **State Management**,
**Dependency Injection**, and **Event Handler**.
These three pillars are the foundation of any Reactter application.
Theses are designed to work together seamlessly,
providing a powerful and flexible framework for building applications.

## State Management

State management is a critical aspect of any application.
It allows you to manage the state of your application,
and facilitates seamless tracking and handling of changes to it.

Reactter provides a variety of mechanisms for state management,
including classes, hooks, and methods:

- Classes
  - [Signal](/reactter/classes/signal)
- Hooks
  - [UseState](/reactter/hooks/use_state)
  - [UseAsyncState](/reactter/hooks/use_async_state)
  - [UseReducer](/reactter/hooks/use_reducer)
  - [UseCompute](/reactter/hooks/use_compute)
- Methods
  - [lazyState](/reactter/methods/to_manage_state/lazy_state)
  - [batch](/reactter/methods/to_manage_state/batch)
  - [untracked](/reactter/methods/to_manage_state/untracked)

<Aside>
  The **hooks** (also known as [`ReactterHook`](https://pub.dev/documentation/reactter/latest/reactter/ReactterHook-class.html)) are named with the prefix `Use` according to convention.
</Aside>

<Aside type="tip">
  Learn about [Custom Hook](/reactter/core_concepts/custom_hook).
</Aside>

### How it works

Reactter's state management system is based on the concept of **reactivity**.
Contrary to the prevailing notion that implementing reactive programming in Dart can be challenging,
Reactter greatly simplifies this process.
To dive into the concept, let's start by exploring what constitutes a state in Reactter.

All state in Reactter are classes that inherit [`ReactterState`](https://pub.dev/documentation/reactter/latest/reactter/ReactterState-class.html),
and Reactter offers two fundamental approaches for creating states: [Signal](/reactter/classes/signal) and Hooks.
This class provides some methods for managing states, which are:

- [update](https://pub.dev/documentation/reactter/latest/reactter/ReactterState/update.html): Executes a callback function and notify its listeners that the state has changed.
When it is invoked, it emits two events to signal the state transition:
`Lifecycle.willUpdate` is emitted first, indicating the impending update, followed by `Lifecycle.didUpdate` once the update process is complete.
- [refresh](https://pub.dev/documentation/reactter/latest/reactter/ReactterState/refresh.html): Forces the state to notify its listeners that it has changed.
Unlike `update`, it emits only the `Lifecycle.didUpdate` event, as it doesn't involve any preparatory steps before the notification.
- [bind](https://pub.dev/documentation/reactter/latest/reactter/ReactterState/bind.html): Establishes a connection between the state and a specific instance.
This connection allows the instance to reactively update based on changes to the state.
By binding the state, the instance becomes aware of changes to the state and can appropriately reflect those changes in its behavior.
- [unbind](https://pub.dev/documentation/reactter/latest/reactter/ReactterState/unbind.html): Releases the connection between the state and the instance.
When unbinding, the instance will no longer receive updates from the state.
This can be useful when an instance is no longer actively using the state or when it needs to detach from the state temporarily or permanently.
- [dispose](https://pub.dev/documentation/reactter/latest/reactter/ReactterState/dispose.html): Is responsible for cleaning up the state and any associated listeners or resources.
Disposing of the state ensures that it is properly released and no longer consumes memory or processing resources unnecessarily.

Although theses methods are available, it's not necessary to use them directly, as Reactter handles state management for you.

### Example

Let's see an example of how a `Signal` state is used and what happens under the hood.

```dart title="main.dart"
import 'dart:async';
import 'package:reactter/reactter.dart';

// Create a reactive state called `count` using the `Signal` class
final count = Signal(10);

void main() async {
  // Listen to the `didUpdate` event of the `count` state
  // and print the `value` of `count` each time it changes
  Reactter.on(
    count,
    Lifecycle.didUpdate,
    (_, __) => print('Count: $count')
  );

  // Create a timer that decrements the `value` of `count`
  // by 1 every second until it reaches 0
  await Timer.periodic(Duration(seconds: 1), countdown);
}

// Decrement the `value` of `count` by 1 each time the timer ticks
// and cancel the `timer` when the `value` of `count` reaches 0
void countdown(Timer timer) {
  count.value -= 1;

  if (count.value == 0) {
    timer.cancel();
  }
}
```

During the process, as the `value` of `count` changes and triggers the `didUpdate` event,
internally within the `Signal` class, the `update` method is invoked to notify its listeners(in line 11 of the code below), as follows:

```dart
class Signal<T> extends ReactterState[...] {
  T _value;

  Signal(this._value);

  T get value => _value;

  set value(T val) {
    if (_value == val) return;

    update((_) => _value = val);
  }

  [...]
}
```

<Aside>
The `bind`, `unbind` and `dispose` methods are normally used to manage the [lifecycle](/reactter/core_concepts/lifecycle) of a state.
However, Reactter handles this automatically, when the state is declared inside an instance that is in the Reactter context using dependecy injection, so you don't need to worry about it.
</Aside>

<Aside type="tip">
  Learn about [Lifecycle](/reactter/core_concepts/lifecycles).
</Aside>

## Dependency Injection

With Reactter, you can create, delete and access the desired object
from a single location, and you can do it from anywhere in the code,
thanks to reactter's dependency injection system.

Dependency injection offers several benefits.
It promotes the principle of inversion of control,
where the control over object creation and management is delegated to Reactter.
This improves code modularity, reusability, and testability.
It also simplifies the code by removing the responsibility of creating dependencies
from individual classes, making them more focused on their core functionality.

Reactter provides the following dependencies injection mechanisms:

- Hooks
  - [UseInstance](/reactter/hooks/UseInstance)
- Methods
  * [register](/reactter/methods/to_manage_instance/register)
  * [lazyBuilder](/reactter/methods/to_manage_instance/lazy_builder)
  * [lazyFactory](/reactter/methods/to_manage_instance/lazy_factory)
  * [lazySingleton](/reactter/methods/to_manage_instance/lazy_singleton)
  * [create](/reactter/methods/to_manage_instance/create)
  * [builder](/reactter/methods/to_manage_instance/builder)
  * [factory](/reactter/methods/to_manage_instance/factory)
  * [singleton](/reactter/methods/to_manage_instance/singleton)
  * [get](/reactter/methods/to_manage_instance/get)
  * [delete](/reactter/methods/to_manage_instance/delete)
  * [unregister](/reactter/methods/to_manage_instance/unregister)
  * [destroy](/reactter/methods/to_manage_instance/destroy)
  * [find](/reactter/methods/to_manage_instance/find)
  * [isRegistered](/reactter/methods/to_manage_instance/is_registered)
  * [getInstanceManageMode](/reactter/methods/to_manage_instance/get_instance_manage_mode)


<Aside type="tip">
If you are using Flutter, go to [Rendering Control](/reactter/core_concepts/rendering_control) to learn how it manage instances through Widgets and BuildContext extension methods.
</Aside>

### How it works

Reactter manages the dependencies through a centralized mechanism.
This core component serves as a central repository for registering, resolving, and providing dependencies across the app.
To comprehend this mechanism thoroughly, let's break down the process into five stages:

1. **Registration**: This stage involves registering the dependency into Reactter's context with the specified `id` and `mode` params.

    For this, you can use the following methods:
      - [`register`](/reactter/methods/to_manage_instance/register)
      - [`lazyBuilder`](/reactter/methods/to_manage_instance/lazy_builder)(registers with `builder` mode)
      - [`lazyFactory`](/reactter/methods/to_manage_instance/lazy_factory)(registers with `factory` mode)
      - [`lazySingleton`](/reactter/methods/to_manage_instance/lazy_singleton)(registers with `singleton` mode)

    The `Lifecycle.registered` event is emitted.

2. **Resolving**: When there is a request for getting a dependency, Reactter gets it according to `id` and the `mode` through the registry.
If the dependency with/without `id` is not yet created, Reactter initializes it based on registry(this condition doesn't apply to `find` method).

    For this, you can use the following methods:
      - [`get`](/reactter/methods/to_manage_instance/get)
      - [`find`](/reactter/methods/to_manage_instance/find)(doesn't create the instance)
      - [`create`](/reactter/methods/to_manage_instance/create)(registers if not found in registry)
      - [`builder`](/reactter/methods/to_manage_instance/builder)(registers with `builder` mode if not found in registry)
      - [`factory`](/reactter/methods/to_manage_instance/factory)(registers with `factory` mode if not found in registry)
      - [`singleton`](/reactter/methods/to_manage_instance/singleton)(registers with `singleton` mode if not found in registry)

    The following events are fired(only if the dependency is created):
      - `Lifecycle.initialized`
      - `Lifecycle.willMount`
      - `Lifecycle.didMount`

3. **Usage**: The dependency is then used across the app as needed.

    Some of these events may occur:
      - `Lifecycle.willUpdate`
      - `Lifecycle.didUpdate`

4. **Deleting**: When the dependency with/without `id` is no longer required, Reactter destroys it.

    For this, you can use the following methods:
      - [`delete`](/reactter/methods/to_manage_instance/delete)
      - [`destroy`](/reactter/methods/to_manage_instance/destroy)(delete & unregister)

    The following events are fired:
      - `Lifecycle.willUnmount`
      - `Lifecycle.didUnmount`
      - `Lifecycle.destroyed`

5. **Unregistration**: When the dependency with/without `id` is no longer required and depending on `mode`, Reactter unregisters it.

    For this, you can use the following methods:
      - [`unregister`](/reactter/methods/to_manage_instance/unregister)
      - [`delete`](/reactter/methods/to_manage_instance/delete)
      - [`destroy`](/reactter/methods/to_manage_instance/destroy)

    The `Lifecycle.unregistered` event is emitted.

<Aside>
`id` and `mode` are optional parameters.

If `id` is not provided, Reactter will resolve the dependency based on the type of the class only.

If `mode` is not provided, Reactter will use the default mode, which is `InstanceManageMode.builder`.
</Aside>

<Aside>
A **dependency** in Reactter is referred to as an **instance** of specific type.
</Aside>

<Aside type="tip">
  Learn about [Lifecycle](/reactter/core_concepts/lifecycles).
</Aside>

### Example

To understand it better, we will return to the countdown example seen from the session on [how state management works](#how-it-works),
but now using the dependency injection:

```dart title="counter.dart"
import 'package:reactter/reactter.dart';

/// A class that represents a counter with a count state
class Counter {
  final Signal<int> _count;

  int get count => _count.value;

  const Counter(int initialValue) : _count = Signal(initialValue);

  void decrement() => count.value -= 1;
}
```

```dart title="countdown.dart"
import 'package:reactter/reactter.dart';
import 'counter.dart';

/// A class that represents a countdown using a counter
class Countdown {
  // Create an instance of the `Counter` class using the `UseInstance` hook
  // and initialize it with an initial value of 10
  final uCounter = UseInstance.create<Counter>(() => Counter(10));

  // Get the instance of the `Counter` class
  Counter get counter => uCounter.instance;

  /// Start the countdown
  Future<void> run() {
    // Listen to the `didUpdate` event of the `counter` instance
    // and print the current `value` of `count` each time it changes
    Reactter.on(
      counter,
      Lifecycle.didUpdate,
      (_, __) => print('Count: ${counter.count}'),
    );

    // Create a timer that decrements the `count` state by 1
    // every second until it reaches 0
    return Timer.periodic(Duration(seconds: 1), _countdown);
  }

  // Decrement the `count` state by 1 each time the timer ticks
  // and delete the `Counter` instance when the count value reaches 0
  void _countdown(Timer timer) {
    counter.decrement();

    if (counter.count == 0) {
      timer.cancel();
      Reactter.delete<Counter>();
    }
  }
}
```

```dart title="main.dart"
import 'package:reactter/reactter.dart';
import 'countdown.dart';

void main() async {
  // Create an instance of the `Countdown` class
  final countdown = Reactter.create(() => Countdown())!;
  // Start the countdown
  await countdown.run();
}
```

In this example, we have create a countdown of 10 seconds, and when it reaches 0, the `Counter` instance is deleted.
But we will make a small tweak to change the countdown behavior.

```dart title="main.dart" ins={5-6}
import 'package:reactter/reactter.dart';
import 'countdown.dart';

void main() async {
  // Register the `Counter` class with an initial value of 20
  Reactter.register(() => Counter(20));
  // Create an instance of the `Countdown` class
  final countdown = Reactter.create(() => Countdown())!;
  // Start the countdown
  await countdown.run();
}
```

Now, the countdown will start from 20 and when it reaches 0, the `Counter` instance is deleted.
What happens is that the `Counter` instance is registered with an initial value of 20,
and when the `Countdown` instance is created, it uses the `Counter` instance registered.

Ok, but what if we want to use the `Counter` instance in another part of the code? Let's look:

```dart title="main.dart" ins={11-14}
import 'package:reactter/reactter.dart';
import 'countdown.dart';

void main() async {
  // Register the `Counter` class with an initial value of 20
  Reactter.register(() => Counter(20));
  // Create an instance of the `Countdown` class
  final countdown = Reactter.create(() => Countdown())!;
  // Start the countdown
  await countdown.run();
  // Get the instance of the `Counter` class
  final counter = Reactter.get<Counter>();
  // Try to print the current count value
  print('Count: ${counter?.count ?? 'Counter instance not found'}');
}
```
In this case, the countdown will work as before, but when trying to get the `Counter` instance to print its value,
the ouput will be _“Counter instance not found”_.
This occurs because `Counter` was registered as `InstanceManageMode.builder`(the default mode),
so when it was deleted at the end of the countdown its registration was also deleted.
If we want to get the `Counter` instance to print its value, we need to register using the `InstanceManageMode.singleton` mode.

Let's now delve into the **modes** of dependency registration.

The **mode** with which a dependency is registered determines how it is managed by Reactter. There are three modes:

- [Builder](#builder)
- [Factory](#factory)
- [Singleton](#singleton)

### Builder

Builder is a ways to manage an instance,
which registers a builder function and creates the instance,
unless it has already done so.

In builder mode, when the dependency tree no longer needs it,
it is completely deleted,
including unregistration (deleting the builder function).

Reactter identifies the builder mode as
[`InstanceManageMode.builder`](https://pub.dev/documentation/reactter/6.0.0/InstanceManageMode/InstanceManageMode.builder.html)
and it's using for default.

<Aside>
  **Builder** uses less RAM than [Factory](#factory) and [Singleton](#singleton),
  but it consumes more CPU than the other modes.
</Aside>

### Factory

Factory is a ways to manage an instance,
which registers a builder function only once
and creates the instance if not already done.

In factory mode, when the dependency tree no longer needs it,
the instance is deleted and the builder function is kept in the register.

Reactter identifies the factory mode as
[`InstanceManageMode.factory`](https://pub.dev/documentation/reactter/6.0.0/InstanceManageMode/InstanceManageMode.factory.html)
and to active it,set it in the `mode` argument of [`Reactter.register`](/reactter/methods/to_manage_instance/register) and [`Reactter.create`](/reactter/methods/to_manage_instance/create),
or use [`Reactter.lazyFactory`](/reactter/methods/to_manage_instance/lazy_factory),  [`Reactter.factory`](/reactter/methods/to_manage_instance/factory).

<Aside>
  **Factory** uses more RAM than [Builder](#builder)
  but not more than [Singleton](#singleton),
  and consumes more CPU than [Singleton](#singleton)
  but not more than [Builder](#builder).
</Aside>

### Singleton

Singleton is a ways to manage an instance,
which registers a builder function and creates the instance only once.

The singleton mode preserves the instance and its states,
even if the dependency tree stops using it.

Reactter identifies the singleton mode as
[`InstanceManageMode.singleton`](https://pub.dev/documentation/reactter/6.0.0/InstanceManageMode/InstanceManageMode.singleton.html)
and to active it,
set it in the `mode` argument of [`Reactter.register`](/reactter/methods/to_manage_instance/register) and [`Reactter.create`](/reactter/methods/to_manage_instance/create),
or use [`Reactter.lazySingleton`](/reactter/methods/to_manage_instance/lazy_singleton), [`Reactter.singleton`](/reactter/methods/to_manage_instance/singleton).

<Aside>
  **Singleton** consumes less CPU than [Builder](#builder) and [Factory](#factory),
  but uses more RAM than the other modes.
</Aside>

<Aside type="tip">
  Use [`Reactter.destroy`](/reactter/methods/to_manage_instance/destroy) if you want to force destroy the instance and its register.
</Aside>

## Event Handler

In Reactter, event handler plays a pivotal role in facilitating seamless communication
and coordination between various components within the application.
The event handler system is designed to ensure efficient state management and dependency injection,
fostering a cohesive ecosystem where different parts of the application can interact harmoniously.

Reactter offers the following event handler mechanisms:

- Hooks
  - [UseEffect](/reactter/hooks/UseEffect)
- Methods
  - [on](/reactter/methods/to_manage_event/on)
  - [one](/reactter/methods/to_manage_event/one)
  - [off](/reactter/methods/to_manage_event/off)
  - [offAll](/reactter/methods/to_manage_event/offAll)
  - [emit](/reactter/methods/to_manage_event/emit)

### How it works

Event handler in Reactter is based on a few fundamental concepts:

- **Event**: An event is a enum that represents a specific action or occurrence in the application.
- **Instance**: An instance is an object that emits and listens to events.
- **Listener**: A listener is a function that is executed when an event is emitted.

Understanding these concepts is crucial for effectively managing event-driven interactions in Reactter apps.

To illustrate this, let's take a countdown example seen from the session on [how state management works](#how-it-works):

```dart title="main.dart"
import 'dart:async';
import 'package:reactter/reactter.dart';

// Create a reactive state called `count` using the `Signal` class
final count = Signal(10);

void main() async {
  // Listen to the `didUpdate` event of the `count` state
  // and print the `value` of `count` each time it changes
  Reactter.on(
    count,
    Lifecycle.didUpdate,
    (_, __) => print('Count: $count')
  );

  // Create a timer that decrements the `value` of `count`
  // by 1 every second until it reaches 0
  await Timer.periodic(Duration(seconds: 1), countdown);
}

// Decrement the `value` of `count` by 1 each time the timer ticks
// and cancel the `timer` when the `value` of `count` reaches 0
void countdown(Timer timer) {
  count.value -= 1;

  if (count.value == 0) {
    timer.cancel();
  }
}
```

In this example, the line 10 to 14, we see that the `on` method is used to subscribe to the `Lifecycle.didUpdate` **event** of the `count` **instance**.
Whenever the `count` state changes, the **listener** function is invoked, printing the current `value` of the `count` state.

Here, we can't see the emitter, because it's encapsulated within the `Signal` class, and it's called when the `value` of the `count` state changes.
This mechanism is made possible by the underlying state management system.

<Aside type="tip">
  Learn about [Lifecycle](/reactter/core_concepts/lifecycles).
</Aside>

Now, we do a small tweak to add an emitter:

```dart title="main.dart" ins={4,18-24,38-39}
import 'dart:async';
import 'package:reactter/reactter.dart';

enum CustomEvent { countdownFinished }

// Create a reactive state called `count` using the `Signal` class
final count = Signal(10);

void main() async {
  // Listen to the `didUpdate` event of the `count` state
  // and print the `value` of `count` each time it changes
  Reactter.on(
    count,
    Lifecycle.didUpdate,
    (_, __) => print('Count: $count')
  );

  // Listen to the `countdownFinished` event
  // and print a message when the countdown is finished
  Reactter.on(
    count,
    CustomEvent.countdownFinished,
    (_, __) => print('Countdown finished!')
  );

  // Create a timer that decrements the `value` of `count`
  // by 1 every second until it reaches 0
  await Timer.periodic(Duration(seconds: 1), countdown);
}

// Decrement the `value` of `count` by 1 each time the timer ticks
// and cancel the `timer` when the `value` of `count` reaches 0
void countdown(Timer timer) {
  count.value -= 1;

  if (count.value == 0) {
    timer.cancel();
    // Emit the `CustomEvent.countdownFinished` event
    Reactter.emit(count, CustomEvent.countdownFinished);
  }
}
```

We added a new **event** called `CustomEvent.countdownFinished` and a new **listener** that prints a message when the countdown is finished.
When the countdown reaches 0, the `count` **instance** emits the `CustomEvent.countdownFinished` event, and the **listener** function is invoked, printing the message.

This example demonstrates how the event handler system in Reactter enables seamless communication between different parts of the application,
facilitating efficient coordination and interaction.
